use async_graphql::{Result, SimpleObject};
use librarian_macros::{GraphQLEntity, GraphQLOperations, GraphQLRelations};
use serde::{Deserialize, Serialize};

#[derive(
    GraphQLEntity,
    GraphQLRelations,
    GraphQLOperations,
    SimpleObject,
    Clone,
    Debug,
    Serialize,
    Deserialize,
)]
#[graphql(name = "RssFeed")]
#[serde(rename_all = "PascalCase")]
#[graphql_entity(table = "rss_feeds", plural = "RssFeeds", default_sort = "name")]
pub struct RssFeed {
    #[graphql(name = "Id")]
    #[primary_key]
    #[filterable(type = "string")]
    pub id: String,

    #[graphql(name = "UserId")]
    #[filterable(type = "string")]
    pub user_id: String,

    #[graphql(name = "LibraryId")]
    #[filterable(type = "string")]
    pub library_id: Option<String>,

    #[graphql(name = "Name")]
    #[filterable(type = "string")]
    #[sortable]
    pub name: String,

    #[graphql(name = "Url")]
    #[filterable(type = "string")]
    pub url: String,

    #[graphql(name = "Enabled")]
    #[filterable(type = "boolean")]
    pub enabled: bool,

    #[graphql(name = "PollIntervalMinutes")]
    #[filterable(type = "number")]
    pub poll_interval_minutes: i32,

    #[graphql(name = "PostDownloadAction")]
    #[filterable(type = "string")]
    pub post_download_action: Option<String>,

    #[graphql(name = "LastPolledAt")]
    #[filterable(type = "date")]
    #[sortable]
    pub last_polled_at: Option<String>,

    #[graphql(name = "LastSuccessfulAt")]
    #[filterable(type = "date")]
    pub last_successful_at: Option<String>,

    #[graphql(name = "LastError")]
    pub last_error: Option<String>,

    #[graphql(name = "ConsecutiveFailures")]
    #[filterable(type = "number")]
    pub consecutive_failures: Option<i32>,

    #[graphql(name = "CreatedAt")]
    #[filterable(type = "date")]
    #[sortable]
    pub created_at: String,

    #[graphql(name = "UpdatedAt")]
    #[filterable(type = "date")]
    #[sortable]
    pub updated_at: String,
}

#[derive(Default)]
pub struct RssFeedCustomOperations;

// #[Object]
// impl RssFeedCustomOperations {
//     /// Parse a filename and identify the media
//     #[graphql(name = "ParseAndIdentifyMedia")]
//     async fn parse_and_identify_media(
//         &self,
//         ctx: &Context<'_>,
//         #[graphql(name = "Title")] title: String,
//     ) -> Result<ParseAndIdentifyMediaResult> {
//         let _user = ctx.auth_user()?;
//         let metadata = ctx.data_unchecked::<Arc<MetadataService>>();

//         let result = metadata.parse_and_identify(&title).await?;

//         Ok(ParseAndIdentifyMediaResult {
//             parsed: ParsedEpisodeInfo {
//                 original_title: result.parsed.original_title,
//                 show_name: result.parsed.show_name,
//                 season: result.parsed.season.map(|s| s as i32),
//                 episode: result.parsed.episode.map(|e| e as i32),
//                 year: result.parsed.year.map(|y| y as i32),
//                 date: result.parsed.date,
//                 resolution: result.parsed.resolution,
//                 source: result.parsed.source,
//                 codec: result.parsed.codec,
//                 hdr: result.parsed.hdr,
//                 audio: result.parsed.audio,
//                 release_group: result.parsed.release_group,
//                 is_proper: result.parsed.is_proper,
//                 is_repack: result.parsed.is_repack,
//             },
//             matches: result.matches.into_iter().map(|r| TvShowSearchResult {
//                 provider: format!("{:?}", r.provider).to_lowercase(),
//                 provider_id: r.provider_id as i32,
//                 name: r.name,
//                 year: r.year,
//                 status: r.status,
//                 network: r.network,
//                 overview: r.overview,
//                 poster_url: r.poster_url,
//                 tvdb_id: r.tvdb_id.map(|id| id as i32),
//                 imdb_id: r.imdb_id,
//                 score: r.score,
//             }).collect(),
//         })
//     }

//     // Note: CRUD operations (Create, Update, Delete) are auto-generated by GraphQLOperations macro.
//     // Use RssFeedEntityMutations.CreateRssFeedEntity, UpdateRssFeedEntity, DeleteRssFeedEntity instead.
//     // The database should have ON DELETE CASCADE on rss_feed_items.feed_id to handle cleanup.

//     /// Test an RSS feed by fetching and parsing its items
//     #[graphql(name = "TestRssFeed")]
//     async fn test_rss_feed(&self, ctx: &Context<'_>, #[graphql(name = "Url")] url: String) -> Result<RssFeedTestResult> {
//         let _user = ctx.auth_user()?;

//         let rss_service = crate::services::RssService::new();
//         match rss_service.fetch_feed(&url).await {
//             Ok(items) => {
//                 let sample_items: Vec<RssItem> = items.into_iter().take(10).map(|item| RssItem {
//                     title: item.title,
//                     link: item.link,
//                     pub_date: item.pub_date.map(|d| d.to_rfc3339()),
//                     description: item.description,
//                     parsed_show_name: item.parsed_show_name,
//                     parsed_season: item.parsed_season,
//                     parsed_episode: item.parsed_episode,
//                     parsed_resolution: item.parsed_resolution,
//                     parsed_codec: item.parsed_codec,
//                 }).collect();

//                 Ok(RssFeedTestResult { success: true, item_count: sample_items.len() as i32, sample_items, error: None })
//             }
//             Err(e) => Ok(RssFeedTestResult { success: false, item_count: 0, sample_items: vec![], error: Some(e.to_string()) }),
//         }
//     }

//     /// Manually poll an RSS feed
//     #[graphql(name = "PollRssFeed")]
//     async fn poll_rss_feed(&self, ctx: &Context<'_>, id: String) -> Result<RssFeedResult> {
//         let user = ctx.auth_user()?;
//         let db = ctx.data_unchecked::<Database>();

//         // Check ownership
//         let existing = EntityQuery::<RssFeedEntity>::new()
//             .filter(&RssFeedEntityWhereInput {
//                 id: Some(StringFilter::eq(&id)),
//                 user_id: Some(StringFilter::eq(&user.user_id)),
//                 ..Default::default()
//             })
//             .fetch_one(db.pool())
//             .await?;

//         if existing.is_none() {
//             return Ok(RssFeedResult { success: false, rss_feed: None, error: Some("RSS feed not found".to_string()) });
//         }

//         let feed_id = Uuid::parse_str(&id)?;

//         match crate::jobs::rss_poller::poll_single_feed_by_id(db, feed_id).await {
//             Ok((_new_items, _matched_episodes)) => {
//                 let updated_feed = EntityQuery::<RssFeedEntity>::new()
//                     .filter(&RssFeedEntityWhereInput {
//                         id: Some(StringFilter::eq(&id)),
//                         ..Default::default()
//                     })
//                     .fetch_one(db.pool())
//                     .await?
//                     .ok_or_else(|| async_graphql::Error::new("RSS feed not found"))?;

//                 Ok(RssFeedResult {
//                     success: true,
//                     rss_feed: Some(entity_to_rss_feed(&updated_feed)),
//                     error: None,
//                 })
//             }
//             Err(e) => {
//                 // Mark poll failure
//                 sqlx::query(
//                     "UPDATE rss_feeds SET consecutive_failures = COALESCE(consecutive_failures, 0) + 1, last_error = ?, last_polled_at = datetime('now'), updated_at = datetime('now') WHERE id = ?"
//                 )
//                 .bind(e.to_string())
//                 .bind(&id)
//                 .execute(db.pool())
//                 .await
//                 .ok();

//                 Ok(RssFeedResult { success: false, rss_feed: None, error: Some(e.to_string()) })
//             }
//         }
//     }
// }

// fn entity_to_rss_feed(entity: &RssFeedEntity) -> RssFeed {
//     RssFeed {
//         id: entity.id.clone(),
//         library_id: entity.library_id.clone(),
//         name: entity.name.clone(),
//         url: entity.url.clone(),
//         enabled: entity.enabled,
//         poll_interval_minutes: entity.poll_interval_minutes,
//         last_polled_at: entity.last_polled_at.clone(),
//         last_successful_at: entity.last_successful_at.clone(),
//         last_error: entity.last_error.clone(),
//         consecutive_failures: entity.consecutive_failures.unwrap_or(0),
//     }
// }
