//! GraphQL schema: QueryRoot and MutationRoot are derived from the entity list
//! via `schema_roots!`. Add a new entity in the entities module and in the
//! list below; Queries/Mutations/CustomOperations are generated by the macro.

use std::sync::Arc;

use async_graphql::dataloader::DataLoader;
use async_graphql::Schema;
use librarian_macros::schema_roots;

use crate::db::Database;
use crate::services::graphql::entities::*;
use crate::services::graphql::loaders::RelationLoader;
use crate::services::graphql::mutations::{AuthMutations, FilesystemMutations};
use crate::services::graphql::queries::FilesystemQueries;
use crate::services::graphql::subscriptions::filesystem::FilesystemChangeBroker;
use crate::services::graphql::subscriptions::FilesystemSubscriptions;
use crate::services::manager::ServicesManager;

schema_roots! {
    query_custom_ops: [User, Torrent],
    entities: [
        Library,
        Movie,
        Show,
        Episode,
        MediaFile,
        Artist,
        Album,
        Track,
        Audiobook,
        Chapter,
        Torrent,
        TorrentFile,
        RssFeed,
        RssFeedItem,
        PendingFileMatch,
        IndexerConfig,
        IndexerSetting,
        IndexerSearchCache,
        User,
        InviteToken,
        RefreshToken,
        AppSetting,
        AppLog,
        VideoStream,
        AudioStream,
        Subtitle,
        MediaChapter,
        PlaybackSession,
        PlaybackProgress,
        CastDevice,
        CastSession,
        CastSetting,
        UsenetServer,
        UsenetDownload,
        ScheduleCache,
        ScheduleSyncState,
        NamingPattern,
        SourcePriorityRule,
        Notification,
        ArtworkCache,
        TorznabCategory,
    ],
    extra_query_types: [FilesystemQueries],
    extra_mutation_types: [AuthMutations, FilesystemMutations, TorrentClientMutations],
    extra_subscription_types: [FilesystemSubscriptions],
}

/// The GraphQL schema type
pub type LibrarianSchema = Schema<QueryRoot, MutationRoot, SubscriptionRoot>;

/// Build the GraphQL schema with all resolvers.
/// Pass the [ServicesManager] so resolvers can obtain the torrent service etc.
pub fn build_schema<E>(db: Database, auth_service: E, services: Arc<ServicesManager>) -> LibrarianSchema
where
    E: Send + Sync + Clone + 'static,
{
    // Create DataLoaders for batching relation queries.
    // Each loader batches queries for a specific (entity_type, fk_column) pair.
    // When multiple parents request their children in the same GraphQL request,
    // all requests are batched into a single SQL query with IN clause.
    //
    // The loaders are keyed by parent ID and return Vec<ChildEntity>.
    // Filtering, sorting, and pagination are applied in-memory after loading.

    // Library -> children
    let shows_loader = DataLoader::new(
        RelationLoader::<Show>::new(db.clone(), "library_id"),
        tokio::spawn,
    );
    let movies_loader = DataLoader::new(
        RelationLoader::<Movie>::new(db.clone(), "library_id"),
        tokio::spawn,
    );
    let artists_loader = DataLoader::new(
        RelationLoader::<Artist>::new(db.clone(), "library_id"),
        tokio::spawn,
    );
    let albums_by_library_loader = DataLoader::new(
        RelationLoader::<Album>::new(db.clone(), "library_id"),
        tokio::spawn,
    );
    let audiobooks_loader = DataLoader::new(
        RelationLoader::<Audiobook>::new(db.clone(), "library_id"),
        tokio::spawn,
    );

    // Show -> Episodes
    let episodes_loader = DataLoader::new(
        RelationLoader::<Episode>::new(db.clone(), "show_id"),
        tokio::spawn,
    );

    // Artist -> Albums
    let albums_by_artist_loader = DataLoader::new(
        RelationLoader::<Album>::new(db.clone(), "artist_id"),
        tokio::spawn,
    );

    // Album -> Tracks
    let tracks_loader = DataLoader::new(
        RelationLoader::<Track>::new(db.clone(), "album_id"),
        tokio::spawn,
    );

    // Audiobook -> Chapters
    let chapters_loader = DataLoader::new(
        RelationLoader::<Chapter>::new(db.clone(), "audiobook_id"),
        tokio::spawn,
    );

    // Torrent -> TorrentFiles
    let torrent_files_loader = DataLoader::new(
        RelationLoader::<TorrentFile>::new(db.clone(), "torrent_id"),
        tokio::spawn,
    );

    Schema::build(
        QueryRoot::default(),
        MutationRoot::default(),
        SubscriptionRoot::default(),
    )
    .data(db)
    .data(auth_service)
    .data(services)
    .data(FilesystemChangeBroker::new(64))
    // Register all relation DataLoaders
    .data(shows_loader)
    .data(movies_loader)
    .data(artists_loader)
    .data(albums_by_library_loader)
    .data(albums_by_artist_loader)
    .data(audiobooks_loader)
    .data(episodes_loader)
    .data(tracks_loader)
    .data(chapters_loader)
    .data(torrent_files_loader)
    .finish()
}
