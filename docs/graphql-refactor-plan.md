GraphQL Type Consistency Refactor Plan
======================================

Goals
-----
- Keep backend GraphQL, Rust domain types, and database schema aligned with a single source of truth per table.
- Provide consistent, table-backed queries/mutations/subscriptions for every DB table.
- Standardize filtering, sorting, pagination, and nested relation loading across all table endpoints.
- Generate frontend TypeScript types from GraphQL schema introspection to prevent drift.

Analysis of /home/toby/dev/gema-2026/crates/jim-service/src/graphql.rs
---------------------------------------------------------------------
- Entity structs derive `GraphQLFilters`, `Relations`, and `SimpleObject`. Per-field attributes declare:
  - `#[graphql(name = "...")]` for GraphQL naming.
  - `#[filterable(type = "string|number|date|boolean")]` to expose filter inputs.
  - `#[sortable]` for `orderBy` support.
  - `#[relation(...)]` for joins and nested selection loading.
  - `#[primary_key]`, `#[db_column]`, `#[date_field]`, `#[boolean_field]` for SQL mapping.
- `resolve_entities` is a shared resolver that:
  - Converts `WhereInput` to a filter struct via `convert_*_where_to_filter`.
  - Applies `limit` and `orderBy` to the filter via `ConfigurableFilter`.
  - Executes SQL via `graphql_orm::fetch_with_filter_and_client`.
  - Loads relations only when requested using `look_ahead` + relation metadata.
- Query root exposes table collections and a single entity lookup (`JimJob`) with relation loading.
- Uses Tiberius/MSSQL via `crate::db::fetch_with_filter_and_client`, and `SupabaseClient`/`VaultManager`
  for connection secrets (not part of core ORM logic).

Dependencies and Macro/Traits Summary (from graphql-orm + graphql-orm-macros)
----------------------------------------------------------------------------
- Traits and helpers (graphql-orm):
  - `DatabaseEntity`: table name, columns list, default sort, primary keys, row conversion.
  - `DatabaseFilter`: `apply_to_where_builder`, sort, limit, column metadata.
  - `FromSqlRow`: converts a DB row to the entity struct.
  - `RelationshipLoader`: loads relations (single and bulk, plus "selective" versions).
  - `RelationMetadataProvider` + registry: enumerates relation names for lookahead traversal.
  - `WhereBuilder`: string-based SQL builder for eq/ne/in/contains/date/bool filters.
  - `OrderByInput` + `ConfigurableFilter`: tie GraphQL inputs to SQL ordering/limits.
- Procedural macros (graphql-orm-macros):
  - `GraphQLFilters` generates:
    - `StructFilter`, `StructWhereInput`, `StructOrderByInput`.
    - `convert_struct_where_to_filter` function.
    - `DatabaseEntity`, `DatabaseFilter`, `OrderByInput`, `ConfigurableFilter` impls.
    - `FromSqlRow` for row decoding, including date/bool helpers.
  - `Relations` generates:
    - `RelationshipLoader` with selective loading based on requested fields.
    - `RelationMetadataProvider` and a registration hook for nested lookahead.
- Current limitations relative to desired behavior:
  - Number filters are limited to eq/ne/in/not_in (no gt/gte/lt/lte).
  - No decimal filter type (only i32 for number filters).
  - SQL generation is string-concatenated (risk of injection if extended).
  - No cursor-based pagination in the ORM layer (only limit + order).
  - Columns are selected wholesale; no field-level SQL projection.

Target Architecture for Librarian
---------------------------------
- Each DB table gets:
  - A Rust module with a DB record type and GraphQL type.
  - Query/mutation/subscription entrypoints aligned with the table.
  - Filters, sort inputs, and connection types generated by a shared macro.
- Query capabilities:
  - Full field selection, nested joins, filtering, sorting.
  - Cursor-based pagination (Relay-style connections) for infinite load.
  - Filters with eq/neq/gt/gte/lt/lte/contains/in/not_in for string, int, decimal, date, boolean.
- Standardized query builder:
  - Use parameterized queries (sqlx `QueryBuilder` or a small internal DSL).
  - Separate "filter plan" from "SQL rendering" for database-specific handling.
- Non-table utility operations (e.g. `ScanLibrary`, `DeleteFile`) live in a
  dedicated GraphQL utility module, while keeping related queries/mutations/
  subscriptions grouped together by domain (beast grouping).

Implementation Plan (Phased)
----------------------------
Phase 1 - Inventory and Model Mapping
- Inventory tables and columns from migrations:
  - `/home/toby/dev/librarian/backend/migrations_sqlite/*.sql`
  - `/home/toby/dev/librarian/backend/migrations/*.sql` (if present in future)
- Map each table to an existing DB module in `/home/toby/dev/librarian/backend/src/db/*.rs`
  or create a new module when missing.
- Identify where the existing GraphQL schema already covers table data in:
  - `/home/toby/dev/librarian/backend/src/graphql/queries/*.rs`
  - `/home/toby/dev/librarian/backend/src/graphql/mutations/*.rs`
  - `/home/toby/dev/librarian/backend/src/graphql/subscriptions.rs`

Phase 2 - ORM and Macro Foundation
- Add a lightweight internal ORM layer modeled on `graphql-orm`:
  - New module location suggestion: `/home/toby/dev/librarian/backend/src/graphql/orm/`
  - Traits: `DatabaseEntity`, `DatabaseFilter`, `FromSqlRow`, `RelationshipLoader`,
    `RelationMetadataProvider`, `OrderByInput`, `ConfigurableFilter`.
  - Query builder: SQLx `QueryBuilder` for SQLite with parameter binding.
  - Extend filter types to include decimal (e.g. `f64` or `rust_decimal::Decimal`).
- Extend `librarian-macros` to include derives similar to `GraphQLFilters` + `Relations`:
  - New macros in `/home/toby/dev/librarian/librarian-macros/src/lib.rs`.
  - Ensure generated code is SQLite-safe and uses parameter binding.

Phase 3 - Table Modules and GraphQL Surface
- Create a per-table GraphQL module layout:
  - Example location: `/home/toby/dev/librarian/backend/src/graphql/tables/<table>.rs`
  - Each module defines:
    - GraphQL type with filterable/sortable fields.
    - Where input + order input from macro.
    - Connection type using `/home/toby/dev/librarian/backend/src/graphql/pagination.rs`.
    - Query, mutation, subscription methods for the table.
- Update GraphQL root wiring in:
  - `/home/toby/dev/librarian/backend/src/graphql/schema.rs`
  - `/home/toby/dev/librarian/backend/src/graphql/queries/mod.rs`
  - `/home/toby/dev/librarian/backend/src/graphql/mutations/mod.rs`
  - `/home/toby/dev/librarian/backend/src/graphql/subscriptions.rs`
- Add a utility module for non-table file/system actions:
  - Example location: `/home/toby/dev/librarian/backend/src/graphql/utility/`
  - Group operations by domain (filesystem/media/scanning) and keep the
    query/mutation/subscription trio together when they operate on the same
    domain objects.

Phase 4 - Filtering, Sorting, Pagination, and Joins
- Implement standardized filter handling for string/int/date/decimal/boolean:
  - Extend filter inputs in `/home/toby/dev/librarian/backend/src/graphql/filters.rs`
    or move into the new ORM module and re-export.
- Add cursor-based pagination per table:
  - Use `/home/toby/dev/librarian/backend/src/graphql/pagination.rs` for connections.
  - Integrate cursor handling into the query builder and GraphQL resolvers.
- Implement selective relation loading:
  - Use lookahead to load only requested relations.
  - Support nested joins by reusing `RelationshipLoader` metadata.

Phase 5 - Frontend Type Generation
- Introduce GraphQL schema introspection + codegen:
  - Add a `pnpm` script in `/home/toby/dev/librarian/frontend/package.json`.
  - Generate types into `/home/toby/dev/librarian/frontend/src/lib/graphql/generated/`.
  - Replace manual types in `/home/toby/dev/librarian/frontend/src/lib/graphql/types.ts`
    with generated types where feasible.
- Update GraphQL client wrappers:
  - `/home/toby/dev/librarian/frontend/src/lib/graphql/client.ts`
  - `/home/toby/dev/librarian/frontend/src/lib/graphql/queries.ts`
  - `/home/toby/dev/librarian/frontend/src/lib/graphql/mutations.ts`
  - `/home/toby/dev/librarian/frontend/src/lib/graphql/subscriptions.ts`

Phase 6 - Migration and Safety
- Incrementally migrate tables to the new table-centric GraphQL modules.
- Keep existing APIs stable while introducing new endpoints to avoid breaking clients.
- Add tests for:
  - Filter semantics and SQL generation.
  - Pagination edge cases and cursor integrity.
  - Relation loading correctness and N+1 prevention.

Risk Notes
----------
- The `graphql-orm` approach uses raw SQL strings; for Librarian we should use
  parameterized SQLx queries to avoid injection risks when adding gt/lt/contains.
- SQLite column types are flexible; ensure strict Rust typing with conversion
  helpers in `/home/toby/dev/librarian/backend/src/db/sqlite_helpers.rs`.
- Ensure GraphQL schema changes are reflected in frontend codegen to avoid stale
  manual types.

Open Questions
--------------
- Do we want one-to-one GraphQL types per DB table, or table types plus
  "view models" for existing domain aggregates?
- Should subscriptions be table-level (row changes) or higher-level domain events?
- Preferred decimal type (`f64` vs `rust_decimal::Decimal`) for money fields?

Resolved Direction (from discussion)
------------------------------------
- Keep both table-backed GraphQL types and view models.
- View models should be built on top of the table modules (filters, joins,
  lookahead, pagination) so that relational data can be reshaped without
  duplicating SQL or business logic.

Examples from current codebase (view models)
-------------------------------------------
- `LibraryFull` combines `LibraryRecord` + `LibraryStats` into a richer shape
  for UI (counts, size, derived fields).
  - Types: `backend/src/graphql/types.rs`
  - Query: `backend/src/graphql/queries/libraries.rs`
  - Stats source: `backend/src/db/libraries.rs`
- `UpcomingEpisode` and `LibraryUpcomingEpisode` are purpose-built types for
  schedule-style views, not direct table rows.
  - Types: `backend/src/graphql/types.rs`
  - Query: `backend/src/graphql/queries/upcoming.rs`
  - DB source for library view: `backend/src/db/episodes.rs`
- `LogStats` is an aggregate view derived from log rows.
  - Types: `backend/src/graphql/types.rs`
  - Query: `backend/src/graphql/queries/logs.rs`
  - DB source: `backend/src/db/logs.rs`
- `TorrentProgress` and `ActiveDownloadCount` are subscription/event view
  models built from service state rather than a single table.
  - Types: `backend/src/graphql/types.rs`
  - Subscriptions: `backend/src/graphql/subscriptions.rs`

How these map to the new model
------------------------------
- Keep table-backed modules as the “source of truth” for data access, filters,
  and relations.
- View model resolvers should compose from table modules (or their repositories)
  to shape the response, reusing filter/order/pagination/relationship helpers
  where applicable.

References (Source Files)
-------------------------
- `/home/toby/dev/gema-2026/crates/jim-service/src/graphql.rs`
- `/home/toby/dev/gema-2026/crates/graphql-orm/src/lib.rs`
- `/home/toby/dev/gema-2026/crates/graphql-orm-macros/src/lib.rs`
- `/home/toby/dev/librarian/backend/src/graphql/filters.rs`
- `/home/toby/dev/librarian/backend/src/graphql/pagination.rs`
- `/home/toby/dev/librarian/backend/src/graphql/schema.rs`
- `/home/toby/dev/librarian/backend/src/db/mod.rs`
- `/home/toby/dev/librarian/backend/migrations_sqlite/*.sql`
- `/home/toby/dev/librarian/frontend/src/lib/graphql/types.ts`
