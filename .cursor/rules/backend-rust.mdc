---
description: Backend Rust patterns and conventions
globs:
  - "backend/src/**/*.rs"
alwaysApply: false
---

# Backend Rust Rules

## GraphQL Schema

### Adding New Queries
Add queries to `QueryRoot` in `src/graphql/schema.rs`:

```rust
#[Object]
impl QueryRoot {
    /// Description of what this query does
    async fn my_query(&self, ctx: &Context<'_>, id: String) -> Result<MyType> {
        let _user = ctx.auth_user()?;  // Require auth
        let db = ctx.data_unchecked::<Database>();
        
        // Implementation
        Ok(result)
    }
}
```

### Adding New Mutations
Add mutations to `MutationRoot` in `src/graphql/schema.rs`:

```rust
#[Object]
impl MutationRoot {
    /// Description of what this mutation does
    async fn create_thing(
        &self,
        ctx: &Context<'_>,
        input: CreateThingInput,
    ) -> Result<ThingResult> {
        let user = ctx.auth_user()?;
        let db = ctx.data_unchecked::<Database>();
        
        // Implementation
        Ok(ThingResult { success: true, error: None })
    }
}
```

### Adding New Subscriptions
Add subscriptions to `SubscriptionRoot` in `src/graphql/subscriptions.rs`:

```rust
#[Subscription]
impl SubscriptionRoot {
    /// Real-time updates for something
    async fn something_updated(
        &self,
        ctx: &Context<'_>,
    ) -> impl Stream<Item = SomethingUpdate> {
        let service = ctx.data_unchecked::<Arc<SomeService>>();
        let rx = service.subscribe();
        
        BroadcastStream::new(rx)
            .filter_map(|result| async move {
                result.ok().map(|event| event.into())
            })
    }
}
```

### GraphQL Types
Define types in `src/graphql/types.rs`:

```rust
// Output type (for queries/subscriptions)
#[derive(Debug, Clone, SimpleObject, Serialize, Deserialize)]
pub struct MyOutputType {
    pub id: String,
    pub name: String,
    // Use Option<T> for nullable fields
    pub description: Option<String>,
}

// Input type (for mutations)
#[derive(Debug, InputObject)]
pub struct MyInputType {
    pub name: String,
    pub description: Option<String>,
}

// Enum type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Enum, Serialize, Deserialize)]
#[graphql(rename_items = "SCREAMING_SNAKE_CASE")]
pub enum MyEnumType {
    OptionOne,
    OptionTwo,
}
```

## Database Patterns

### Creating a Repository
Add new repositories in `src/db/`:

```rust
// src/db/my_entity.rs
use anyhow::Result;
use sqlx::PgPool;
use uuid::Uuid;

#[derive(Debug, Clone, sqlx::FromRow)]
pub struct MyEntityRecord {
    pub id: Uuid,
    pub name: String,
    // Match database column types
}

pub struct MyEntityRepository {
    pool: PgPool,
}

impl MyEntityRepository {
    pub fn new(pool: PgPool) -> Self {
        Self { pool }
    }

    pub async fn get_by_id(&self, id: Uuid) -> Result<Option<MyEntityRecord>> {
        let record = sqlx::query_as::<_, MyEntityRecord>(
            "SELECT * FROM my_entities WHERE id = $1"
        )
        .bind(id)
        .fetch_optional(&self.pool)
        .await?;
        
        Ok(record)
    }

    pub async fn create(&self, name: &str) -> Result<MyEntityRecord> {
        let record = sqlx::query_as::<_, MyEntityRecord>(
            "INSERT INTO my_entities (name) VALUES ($1) RETURNING *"
        )
        .bind(name)
        .fetch_one(&self.pool)
        .await?;
        
        Ok(record)
    }
}
```

Then register in `src/db/mod.rs`:

```rust
pub mod my_entity;
pub use my_entity::{MyEntityRecord, MyEntityRepository};

impl Database {
    pub fn my_entities(&self) -> MyEntityRepository {
        MyEntityRepository::new(self.pool.clone())
    }
}
```

### Migrations
- Create migrations in `backend/migrations/`
- Number sequentially: `001_`, `002_`, `003_`, etc.
- Use descriptive names: `003_app_settings.sql`
- Always include `IF NOT EXISTS` for safety

```sql
-- migrations/004_my_feature.sql
CREATE TABLE IF NOT EXISTS my_entities (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Enable RLS if user-scoped
ALTER TABLE my_entities ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can manage own entities"
    ON my_entities FOR ALL
    USING (auth.uid() = user_id);

-- Add updated_at trigger
CREATE TRIGGER set_updated_at_my_entities
    BEFORE UPDATE ON my_entities
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at();
```

## Service Patterns

### Creating a Service
Services encapsulate business logic:

```rust
// src/services/my_service.rs
use std::sync::Arc;
use anyhow::Result;
use tokio::sync::broadcast;

pub struct MyService {
    db: Database,
    event_tx: broadcast::Sender<MyEvent>,
}

impl MyService {
    pub async fn new(db: Database) -> Result<Self> {
        let (event_tx, _) = broadcast::channel(1024);
        Ok(Self { db, event_tx })
    }

    pub fn subscribe(&self) -> broadcast::Receiver<MyEvent> {
        self.event_tx.subscribe()
    }

    pub async fn do_something(&self) -> Result<()> {
        // Business logic
        let _ = self.event_tx.send(MyEvent::SomethingHappened);
        Ok(())
    }
}
```

Register in `src/services/mod.rs` and initialize in `main.rs`.

## Error Handling

### Use `anyhow` for Internal Errors
```rust
use anyhow::{Context, Result};

async fn my_function() -> Result<Thing> {
    let result = some_operation()
        .await
        .context("Failed to do something")?;
    Ok(result)
}
```

### Return User-Friendly Errors from GraphQL
```rust
async fn my_mutation(&self, ctx: &Context<'_>) -> Result<MutationResult> {
    match self.do_thing().await {
        Ok(_) => Ok(MutationResult { success: true, error: None }),
        Err(e) => Ok(MutationResult { 
            success: false, 
            error: Some(e.to_string()) 
        }),
    }
}
```

## Authentication

### Require Auth in Resolvers
```rust
// Get authenticated user (returns error if not authenticated)
let user = ctx.auth_user()?;

// User info available
let user_id = Uuid::parse_str(&user.user_id)?;
let email = &user.email;
let role = &user.role;
```

### The AuthUser Struct
Located in `src/graphql/auth.rs`:
- `user_id`: Supabase user ID
- `email`: User's email (optional)
- `role`: User's role (e.g., "authenticated", "admin")

## Logging

Use `tracing` for structured logging:

```rust
use tracing::{info, warn, error, debug};

info!(path = %config.download_dir.display(), "Download directory ready");
warn!(error = %e, "Something went wrong but we can continue");
error!(error = %e, "Fatal error");
debug!(data = ?some_struct, "Debug info");
```
