---
description: Feature-specific implementation guidelines
globs:
  - "backend/src/**/*.rs"
  - "frontend/src/**/*.ts"
  - "frontend/src/**/*.tsx"
alwaysApply: false
---

# Feature Implementation Rules

## Torrent Client

### Native librqbit Integration
- The torrent client is `librqbit`, a native Rust BitTorrent library
- Do NOT use external torrent clients (qBittorrent, Transmission, etc.)
- The `TorrentService` wraps librqbit and provides:
  - Adding torrents (magnet, URL, file upload)
  - Progress tracking via broadcast channels
  - Database persistence for resume on restart
  - Settings loaded from database

### Torrent State Flow
```
QUEUED → CHECKING → DOWNLOADING → SEEDING
                 ↓
              PAUSED ← (user action)
                 ↓
              ERROR
```

### Events
Torrent events are broadcast to subscribers:
- `TorrentEvent::Added` - New torrent added
- `TorrentEvent::Progress` - Progress update (every second)
- `TorrentEvent::Completed` - Download finished
- `TorrentEvent::Removed` - Torrent removed

### Settings
Torrent settings are stored in `app_settings` table:
- `torrent.download_dir` - Where files are saved
- `torrent.session_dir` - Session/resume data
- `torrent.enable_dht` - DHT for peer discovery
- `torrent.listen_port` - Incoming connections port
- `torrent.max_concurrent` - Max simultaneous downloads
- `torrent.upload_limit` - Upload speed limit (0 = unlimited)
- `torrent.download_limit` - Download speed limit (0 = unlimited)

## Media Library

### Library Types
```rust
pub enum LibraryType {
    Movies,    // Single files per item
    Tv,        // Shows with seasons/episodes
    Music,     // Albums/tracks
    Audiobooks,// Similar to music
    Other,     // Generic files
}
```

### Media Scanning
- Libraries are scanned to discover media files
- Metadata is fetched from TVDB/TMDB
- Files are stored in `media_files` table
- Artwork is cached in Supabase Storage

### Streaming
- HLS (HTTP Live Streaming) for video playback
- On-the-fly transcoding for incompatible formats
- Direct play when browser supports the format

## Subscriptions (TV Show Monitoring)

### Subscription Flow
1. User subscribes to a TV show (by TVDB ID)
2. System monitors for new episodes
3. When new episode airs, search for torrents via RSS feeds
4. Auto-download matching quality profile
5. Move to library after completion

## RSS Feed System

### RSS Polling
- RSS feeds are polled every 15 minutes (configurable per feed)
- Feeds are managed in `/settings/rss`
- Each item is parsed to extract show name, season, episode, quality

### Episode Status Flow
```
missing → wanted → available → downloading → downloaded
```

- `missing`: Episode hasn't aired yet
- `wanted`: Episode should be downloaded
- `available`: RSS match found, torrent link stored
- `downloading`: Torrent is being downloaded
- `downloaded`: Episode file exists

### Auto-Download
- Every 5 minutes, check for episodes with `available` status
- Start downloading via the torrent service
- Update status to `downloading`

### GraphQL Operations
- `rssFeeds` - List all feeds
- `createRssFeed` / `updateRssFeed` / `deleteRssFeed` - CRUD
- `testRssFeed` - Test a URL without storing
- `pollRssFeed` - Manually poll a feed

### Quality Filters (Per-Library)
Quality filters are embedded in library settings (not separate profiles):
- **Video libraries (TV, Movies)**: Resolution, video codec, HDR, audio format, source
- **Audio libraries (Music, Audiobooks)**: Audio format (FLAC/MP3/etc), bit depth, sample rate

Quality filters are type-aware in the UI - music libraries show audio-specific filters.

## Settings System

### Adding New Settings
1. Add migration with default value:
```sql
INSERT INTO app_settings (key, value, description, category) VALUES
    ('feature.setting_name', '"default_value"', 'Description', 'category');
```

2. Access in code:
```rust
let settings = db.settings();
let value: String = settings
    .get_or_default("feature.setting_name", "fallback".to_string())
    .await?;
```

3. Add GraphQL query/mutation if user-configurable

### Setting Categories
- `general` - App-wide settings
- `torrent` - Torrent client settings
- `media` - Media library settings
- `notifications` - Notification preferences

## File Browser

### Usage
The file browser API is for server-side directory selection:
- `GET /api/filesystem/browse?path=/some/path&dirs_only=true`
- `POST /api/filesystem/mkdir` - Create directories

### Security
- Filesystem browsing requires authentication
- No path restrictions currently (admin feature)
- Shows readable/writable status

## Background Jobs

### Job Types
Jobs are stored in the `jobs` table:
- `scan_library` - Scan a library for new media
- `fetch_metadata` - Fetch metadata for media item
- `download_artwork` - Download and cache artwork
- `check_subscriptions` - Check for new episodes

### Job States
```
pending → running → completed
              ↓
           failed (retries up to max_attempts)
```

## Torrent Indexers

### Native Indexer System
The indexer system provides Jackett-like functionality natively in Rust:
- **No external dependencies** - indexers are built into the backend
- **GraphQL management** - all configuration via GraphQL API
- **Torznab compatibility** - exposes `/api/torznab/{id}` for external tools
- **Encrypted credentials** - cookies/passwords stored encrypted in database

### Supported Indexers
- **IPTorrents** - Private tracker with cookie-based auth
- **Cardigann** (planned) - YAML-based generic indexer definitions

### Indexer Configuration
```graphql
# Create an indexer
mutation {
  createIndexer(input: {
    name: "My IPTorrents"
    indexerType: "iptorrents"
    credentials: { cookie: "uid=...; pass=..." }
  }) { success indexer { id } }
}

# Search across indexers
query {
  searchIndexers(query: "show name", indexerIds: [...]) {
    results { title size seeders link }
  }
}
```

### Security
- Encryption key stored in `app_settings` table (auto-generated on first use)
- Credentials encrypted with AES-256-GCM
- Changing the encryption key invalidates all stored credentials

### Integration with Auto Hunt
The indexer system powers the **Auto Hunt** feature. Auto Hunt is **event-driven**:

**Triggers:**
1. **On Add** - Adding a movie/album/audiobook immediately triggers hunt for that item
2. **After Scan** - Library scans trigger auto-hunt for all missing content
3. **Manual** - `triggerAutoHunt` GraphQL mutation

**Flow:**
1. Find missing items in library (monitored=true, has_file=false)
2. Search enabled indexers for matching releases
3. Filter by library's quality settings (resolution, codec, source, etc.)
4. Score and rank releases (seeders, freeleech, preferred groups)
5. Download best match via IndexerManager (with proper authentication)
6. Link torrent to item in database
7. Download monitor handles post-processing and organization

**Note:** Auto Hunt does NOT run on a fixed schedule. It's purely event-driven.

### UI Location
- **Settings → Indexers** - Configure indexer sources
- Enable/disable indexers with toggle switch
- Test connection to verify credentials
- Global search box to test queries across all enabled indexers

## Hunt System (Manual Search)

### Routes
- `/hunt` - Search across all indexers for torrents
- `/search` - Search local library content (navbar modal)

### Hunt Page Features
- Search input with media type filter (TV, Movies, Music, etc.)
- DataTable with search results from all enabled indexers
- Actions: Download, Download + Add to Library
- Deep linking: `/hunt?q=Show+Name&type=tv` pre-fills search

### Local Search (Navbar)
- Global keyboard shortcut: Cmd/Ctrl+K
- Opens modal with instant search across all library content
- Shows TV shows and movies with poster thumbnails
- Click result to navigate to detail page
- "Hunt for X online" link when no local results

### Download Flow
```
User searches on /hunt
    ↓
Selects release → clicks "Download + Add to Library"
    ↓
AddToLibraryModal opens
    ↓
User selects library (and album for music, or searches for show/movie)
    ↓
System downloads torrent (authenticated via IndexerManager)
    ↓
Links torrent to item in database
    ↓
Episode/Movie status → "Downloading"
    ↓
Download completes → auto-organization
    ↓
Status → "Downloaded"
```

## Two Content Acquisition Workflows

Librarian supports two ways to acquire content:

### 1. Library-First Workflow
Start from the library, add what you want, system finds and downloads it.

```
Add Movie/Album/Audiobook to Library
    ↓
Auto Hunt triggers immediately
    ↓
Search indexers for content
    ↓
Download best matching release
    ↓
Organize into library folder
```

### 2. Torrent-First Workflow
Find a torrent first, then add it to your library.

```
Search on /hunt page
    ↓
Download torrent
    ↓
Go to /downloads, click "Link to Library"
    ↓
Select library (with auto_add_discovered enabled)
    ↓
System auto-creates entry:
  - Movies: Search TMDB, create movie
  - Music: Search MusicBrainz, create album
  - Audiobooks: Search OpenLibrary, create audiobook
  - TV: Match to existing show/episode
    ↓
Link torrent to new entry
    ↓
Organize files into library
```

**Key setting:** `auto_add_discovered` must be enabled on the library for the torrent-first workflow to auto-create entries.

## Unified Content Acquisition Pipeline

### Auto-Adding on Link
When linking a torrent to a library (without a specific item):
1. Parse torrent name for title/artist/author info
2. Search appropriate metadata provider:
   - Movies → TMDB
   - Music → MusicBrainz  
   - Audiobooks → OpenLibrary
   - TV → Match existing shows
3. Create entry in library if match found
4. Link torrent to new entry
5. Process and organize files

### Force Reprocessing
When a torrent is "stuck" (downloaded but not organized correctly):
1. Manual "Organize" action from /downloads
2. Deletes existing media_file records in downloads path
3. Resets has_file flags on linked items
4. Re-runs full processing pipeline
5. Organizes files fresh

### Library Consolidation
Clean up duplicate folders after naming convention changes:
```graphql
mutation {
  consolidateLibrary(id: "library-id") {
    success
    foldersRemoved
    filesMoved
    messages
  }
}
```

Handles:
- Merging "Show" and "Show (2024)" folders
- Moving loose files from library root to proper structure
- Updating database paths to match filesystem
- Removing empty folders after consolidation

## Planned Features

### Notifications
- Push notifications for:
  - Download complete
  - New episode available
  - Error alerts

### Multi-user Support
- Row-level security in PostgreSQL
- Per-user libraries and preferences
- Admin role for system settings

### Mobile App
- React Native or Flutter
- Same GraphQL API
- Push notifications

## Implementation Priorities

When adding features, prioritize:
1. **Database schema first** - Migrations before code
2. **Backend service** - Business logic in services
3. **GraphQL API** - Expose via queries/mutations
4. **Frontend UI** - React components with HeroUI
5. **Real-time updates** - Add subscriptions if needed
