---
description: Feature-specific implementation guidelines
globs:
  - "backend/src/**/*.rs"
  - "frontend/src/**/*.ts"
  - "frontend/src/**/*.tsx"
alwaysApply: false
---

# Feature Implementation Rules

## Torrent Client

### Native librqbit Integration
- The torrent client is `librqbit`, a native Rust BitTorrent library
- Do NOT use external torrent clients (qBittorrent, Transmission, etc.)
- The `TorrentService` wraps librqbit and provides:
  - Adding torrents (magnet, URL, file upload)
  - Progress tracking via broadcast channels
  - Database persistence for resume on restart
  - Settings loaded from database

### Torrent State Flow
```
QUEUED → CHECKING → DOWNLOADING → SEEDING
                 ↓
              PAUSED ← (user action)
                 ↓
              ERROR
```

### Events
Torrent events are broadcast to subscribers:
- `TorrentEvent::Added` - New torrent added
- `TorrentEvent::Progress` - Progress update (every second)
- `TorrentEvent::Completed` - Download finished
- `TorrentEvent::Removed` - Torrent removed

### Settings
Torrent settings are stored in `app_settings` table:
- `torrent.download_dir` - Where files are saved
- `torrent.session_dir` - Session/resume data
- `torrent.enable_dht` - DHT for peer discovery
- `torrent.listen_port` - Incoming connections port
- `torrent.max_concurrent` - Max simultaneous downloads
- `torrent.upload_limit` - Upload speed limit (0 = unlimited)
- `torrent.download_limit` - Download speed limit (0 = unlimited)

## Media Library

### Library Types
```rust
pub enum LibraryType {
    Movies,    // Single files per item
    Tv,        // Shows with seasons/episodes
    Music,     // Albums/tracks
    Audiobooks,// Similar to music
    Other,     // Generic files
}
```

### Media Scanning
- Libraries are scanned to discover media files
- Metadata is fetched from TVDB/TMDB
- Files are stored in `media_files` table
- Artwork is cached in Supabase Storage

### Streaming
- HLS (HTTP Live Streaming) for video playback
- On-the-fly transcoding for incompatible formats
- Direct play when browser supports the format

## Subscriptions (TV Show Monitoring)

### Subscription Flow
1. User subscribes to a TV show (by TVDB ID)
2. System monitors for new episodes
3. When new episode airs, search for torrents via RSS feeds
4. Auto-download matching quality profile
5. Move to library after completion

## RSS Feed System

### RSS Polling
- RSS feeds are polled every 15 minutes (configurable per feed)
- Feeds are managed in `/settings/rss`
- Each item is parsed to extract show name, season, episode, quality

### Episode Status Flow
```
missing → wanted → available → downloading → downloaded
```

- `missing`: Episode hasn't aired yet
- `wanted`: Episode should be downloaded
- `available`: RSS match found, torrent link stored
- `downloading`: Torrent is being downloaded
- `downloaded`: Episode file exists

### Auto-Download
- Every 5 minutes, check for episodes with `available` status
- Start downloading via the torrent service
- Update status to `downloading`

### GraphQL Operations
- `rssFeeds` - List all feeds
- `createRssFeed` / `updateRssFeed` / `deleteRssFeed` - CRUD
- `testRssFeed` - Test a URL without storing
- `pollRssFeed` - Manually poll a feed

### Quality Profiles
Quality profiles define preferred formats:
- Resolution preferences (4K > 1080p > 720p)
- Codec preferences (x265 > x264)
- Source preferences (BluRay > WEB-DL > HDTV)
- Size limits

## Settings System

### Adding New Settings
1. Add migration with default value:
```sql
INSERT INTO app_settings (key, value, description, category) VALUES
    ('feature.setting_name', '"default_value"', 'Description', 'category');
```

2. Access in code:
```rust
let settings = db.settings();
let value: String = settings
    .get_or_default("feature.setting_name", "fallback".to_string())
    .await?;
```

3. Add GraphQL query/mutation if user-configurable

### Setting Categories
- `general` - App-wide settings
- `torrent` - Torrent client settings
- `media` - Media library settings
- `notifications` - Notification preferences

## File Browser

### Usage
The file browser API is for server-side directory selection:
- `GET /api/filesystem/browse?path=/some/path&dirs_only=true`
- `POST /api/filesystem/mkdir` - Create directories

### Security
- Filesystem browsing requires authentication
- No path restrictions currently (admin feature)
- Shows readable/writable status

## Background Jobs

### Job Types
Jobs are stored in the `jobs` table:
- `scan_library` - Scan a library for new media
- `fetch_metadata` - Fetch metadata for media item
- `download_artwork` - Download and cache artwork
- `check_subscriptions` - Check for new episodes

### Job States
```
pending → running → completed
              ↓
           failed (retries up to max_attempts)
```

## Torrent Indexers

### Native Indexer System
The indexer system provides Jackett-like functionality natively in Rust:
- **No external dependencies** - indexers are built into the backend
- **GraphQL management** - all configuration via GraphQL API
- **Torznab compatibility** - exposes `/api/torznab/{id}` for external tools
- **Encrypted credentials** - cookies/passwords stored encrypted in database

### Supported Indexers
- **IPTorrents** - Private tracker with cookie-based auth
- **Cardigann** (planned) - YAML-based generic indexer definitions

### Indexer Configuration
```graphql
# Create an indexer
mutation {
  createIndexer(input: {
    name: "My IPTorrents"
    indexerType: "iptorrents"
    credentials: { cookie: "uid=...; pass=..." }
  }) { success indexer { id } }
}

# Search across indexers
query {
  searchIndexers(query: "show name", indexerIds: [...]) {
    results { title size seeders link }
  }
}
```

### Security
- Encryption key stored in `app_settings` table (auto-generated on first use)
- Credentials encrypted with AES-256-GCM
- Changing the encryption key invalidates all stored credentials

### Integration with Auto Hunt
The indexer system is designed to power the **Auto Hunt** feature:
1. Library/show has "Auto Hunt" enabled with quality profile
2. System detects wanted episodes (missing or upgradeable)
3. Searches enabled indexers for matching releases
4. Filters by quality/format/audio preferences from quality profile
5. Automatically adds matching torrents to download queue
6. Post-download processing organizes files into library

### UI Location
- **Settings → Indexers** - Configure indexer sources
- Enable/disable indexers with toggle switch
- Test connection to verify credentials
- Global search box to test queries across all enabled indexers

## Hunt System (Manual Search)

### Routes
- `/hunt` - Search across all indexers for torrents
- `/search` - Search local library content (navbar modal)

### Hunt Page Features
- Search input with media type filter (TV, Movies, Music, etc.)
- DataTable with search results from all enabled indexers
- Actions: Download, Download + Add to Library
- Deep linking: `/hunt?q=Show+Name&type=tv` pre-fills search

### Local Search (Navbar)
- Global keyboard shortcut: Cmd/Ctrl+K
- Opens modal with instant search across all library content
- Shows TV shows and movies with poster thumbnails
- Click result to navigate to detail page
- "Hunt for X online" link when no local results

### Download Flow
```
User searches on /hunt
    ↓
Selects release → clicks "Download + Add to Library"
    ↓
AddToLibraryModal opens
    ↓
User selects library, searches for show/movie
    ↓
System downloads torrent (authenticated if private tracker)
    ↓
Auto-matches to episode, links in database
    ↓
Episode status → "Downloading"
    ↓
Download completes → auto-organization
    ↓
Episode status → "Downloaded"
```

## Unified Content Acquisition Pipeline

### Auto-Matching at Add Time
When a torrent is added with a library_id but no episode_id:
1. Parse torrent name for show/season/episode
2. Find matching show in library
3. Find matching episode
4. Link torrent to episode
5. Mark episode as "Downloading"

### Auto-Matching at Completion (No Library)
When a torrent completes without any library context:
1. Get user's libraries
2. Parse filename for show/season/episode
3. Try to match against each TV library
4. If match found: create media file, link torrent, organize

### Library Consolidation
Clean up duplicate folders after naming convention changes:
```graphql
mutation {
  consolidateLibrary(id: "library-id") {
    success
    foldersRemoved
    filesMoved
    messages
  }
}
```

Handles:
- Merging "Show" and "Show (2024)" folders
- Moving loose files from library root to proper structure
- Updating database paths to match filesystem
- Removing empty folders after consolidation

## Planned Features

### Notifications
- Push notifications for:
  - Download complete
  - New episode available
  - Error alerts

### Multi-user Support
- Row-level security in PostgreSQL
- Per-user libraries and preferences
- Admin role for system settings

### Mobile App
- React Native or Flutter
- Same GraphQL API
- Push notifications

## Implementation Priorities

When adding features, prioritize:
1. **Database schema first** - Migrations before code
2. **Backend service** - Business logic in services
3. **GraphQL API** - Expose via queries/mutations
4. **Frontend UI** - React components with HeroUI
5. **Real-time updates** - Add subscriptions if needed
