---
description: Core architecture decisions and patterns for the Librarian project
globs:
  - "backend/src/**/*.rs"
  - "frontend/src/**/*.ts"
  - "frontend/src/**/*.tsx"
alwaysApply: true
---

# Architecture Rules

## API Design

### GraphQL First
- **ALL API endpoints MUST use GraphQL** for queries, mutations, and subscriptions
- The GraphQL endpoint is at `/graphql` (HTTP) and `/graphql/ws` (WebSocket)
- Do NOT create new REST endpoints except for:
  - Health checks (`/healthz`, `/readyz`)
  - File uploads (multipart form data doesn't work well with GraphQL)
  - Filesystem browsing (simple REST is cleaner for this)
- Authentication is handled via JWT in the `Authorization: Bearer <token>` header
- All GraphQL operations require authentication except `health` and `version` queries

### Real-time Updates via Subscriptions
- Use GraphQL subscriptions for any real-time data (torrent progress, scan status, etc.)
- Subscriptions use WebSocket at `/graphql/ws`
- The frontend uses `urql` with `graphql-ws` for subscriptions
- Backend broadcasts events via `tokio::sync::broadcast` channels

## Backend Structure (Rust/Axum)

```
backend/
├── src/
│   ├── api/          # REST endpoints (only for file uploads, filesystem, health)
│   ├── config/       # Configuration loading
│   ├── db/           # Database repositories (one per entity)
│   ├── graphql/      # GraphQL schema, types, subscriptions, auth
│   ├── jobs/         # Background job definitions
│   ├── media/        # Media processing (HLS, transcoding)
│   ├── services/     # Business logic services
│   └── torrent/      # Torrent-specific logic (quality profiles, parsing)
├── migrations/       # SQL migrations (numbered: 001_, 002_, etc.)
```

### Service Pattern
- Services are created once at startup and shared via `Arc<T>`
- Services are injected into GraphQL context via `Schema.data()`
- Repositories are lightweight and created on-demand from `Database`

### Database Access
- Use `sqlx` with compile-time query checking
- All database operations go through repository structs in `src/db/`
- Use `Database` struct as the main entry point (provides `.torrents()`, `.settings()`, etc.)

## Frontend Structure (React/TanStack Router)

```
frontend/
├── src/
│   ├── components/   # Reusable UI components
│   ├── hooks/        # Custom React hooks
│   ├── lib/          # Utilities, API clients, GraphQL operations
│   └── routes/       # File-based routing (TanStack Router)
```

### State Management
- Use React hooks for local state
- Use GraphQL cache (urql) for server state
- Subscriptions for real-time updates
- No Redux or external state management needed

## Key Technologies

| Layer | Technology |
|-------|------------|
| Backend Runtime | Rust + Tokio |
| Backend Framework | Axum |
| API | async-graphql |
| Database | PostgreSQL via Supabase |
| ORM | sqlx (raw SQL with compile-time checks) |
| Torrent Client | librqbit (native Rust) |
| Frontend | React 19 + TypeScript |
| Router | TanStack Router |
| GraphQL Client | urql + graphql-ws |
| UI Components | HeroUI |
| Styling | Tailwind CSS v4 |
| Auth | Supabase Auth (JWT) |
